#!/usr/bin/python3

from ctypes import cdll, c_void_p, c_int, c_char_p, c_uint, byref
from enum import IntEnum
from subprocess import check_output

import psutil
import argparse
import http.server

from libknot.control import *

from prometheus_client.core import REGISTRY
from prometheus_client.core import GaugeMetricFamily
from prometheus_client.exposition import MetricsHandler

def memory_usage():
    out = dict()
    pids = check_output(['pidof', 'knotd']).split(b'\n')
    for pid in pids:
        if not pid:
            continue
        key = int(pid)
        out[key] = psutil.Process(key).memory_info()._asdict()['rss']
    return out

class KnotCollector(object):
    def __init__(self, lib, sock, ttl):
        load_lib(lib)
        self._sock = sock
        self._ttl = ttl

    def collect(self):
        ctl = KnotCtl()
        ctl.connect(self._sock)
        ctl.set_timeout(self._ttl)

        # Get global metrics.
        for pid, usage in memory_usage().items():
            m = GaugeMetricFamily('knot_memory_usage', '', labels=['section', 'type'])
            m.add_metric(['server', str(pid)], usage)
            yield m

        ctl.send_block(cmd="stats", flags="")
        global_stats = ctl.receive_stats()

        for section, section_data in global_stats.items():
            for item, item_data in section_data.items():
                name = ('knot_' + item).replace('-', '_')
                try:
                    for kind, kind_data in item_data.items():
                        m = GaugeMetricFamily(name, '',
                                labels=['section', 'type'])
                        m.add_metric([section, kind], kind_data)
                        yield m
                except AttributeError:
                    m = GaugeMetricFamily(name, '',
                            labels=['section'])
                    m.add_metric([section], item_data)
                    yield m

        # Get zone metrics.
        ctl.send_block(cmd="zone-stats", flags="")
        zone_stats = ctl.receive_stats()

        if "zone" in zone_stats:
            for zone, zone_data in zone_stats["zone"].items():
                for section, section_data in zone_data.items():
                    for item, item_data in section_data.items():
                        name = ('knot_' + item).replace('-', '_')
                        try:
                            for kind, kind_data in item_data.items():
                                m = GaugeMetricFamily(name, '',
                                        labels=['zone', 'section', 'type'])
                                m.add_metric([zone, section, kind], kind_data)
                                yield m
                        except AttributeError:
                            m = GaugeMetricFamily(name, '',
                                    labels=['zone', 'section'])
                            m.add_metric([zone, section], item_data)
                            yield m

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        formatter_class = argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "--web-listen-addr",
        default="127.0.0.1",
        help="address on which to expose metrics."
    )

    parser.add_argument(
        "--web-listen-port",
        type=int,
        default=9433,
        help="port on which to expose metrics."
    )

    parser.add_argument(
        "--knot-library-path",
        default="libknot.so",
        help="path to libknot."
    )

    parser.add_argument(
        "--knot-socket-path",
        default="/run/knot/knot.sock",
        help="path to knot control socket."
    )

    parser.add_argument(
        "--knot-socket-timeout",
        type=int,
        default=2000,
        help="timeout for Knot control socket operations."
    )

    args = parser.parse_args()

    REGISTRY.register(KnotCollector(
        args.knot_library_path,
        args.knot_socket_path,
        args.knot_socket_timeout,
    ))

    httpd = http.server.HTTPServer(
        (args.web_listen_addr, args.web_listen_port),
        MetricsHandler,
    )

    httpd.serve_forever()
